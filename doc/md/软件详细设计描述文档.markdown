# 企业进销存系统 SIMS(Sales Invoicing Management System)

# 软件详细设计描述文档

# 草稿

## plsw软工二小组

## 2017-10-30


## 目录

### 1.引言

    **1.1　编制目的**
    **1.2　词汇表**
    **1.3　参考资料**

### 2.产品概述

### 3.体系结构设计概述

### 4.结构视角

    **4.1　业务逻辑层的分解**

## 更新历史

| **修改人员** | **日期**     | **变更原因** | **版本号** |
| -------- | ---------- | -------- | ------- |
| 王灿灿 | 2017-10-30 | 添加accountbl模块 | v1.1 |
| 潘星宇 | 2017-11-01 | 添加commoditybl模块 | v1.1 |
| 李杰 | 2017-11-02 | 添加salesbl模块、memberbl模块 | v1.1 |
| 潘星宇 | 2017-11-05 | 添加userbl模块 | v1.1 |
| 李杰 | 2017-11-07 | 添加purchase模块 | v1.1 |
| 孙嘉杰 | 2017-11-08 | 添加promotionbl模块 | v1.1 |
| 潘星宇 | 2017-11-08 | 添加billbl模块 | v1.1 |
| 潘星宇 | 2017-11-08 | 修改commoditybl模块 | v1.2 |
| 潘星宇 | 2017-11-08 | 添加mainui模块 | v1.1 |
| 王灿灿 | 2017-11-10 | 添加mfdoc模块，setupaccount模块 | v1.1 |
| 潘星宇 | 2017-11-12 | 修改commoditybl模块 | v1.3 |
| 潘星宇 | 2017-11-12 | 添加commodityui模块 | v1.1 |
| 潘星宇 | 2017-11-12 | 添加userui模块 | v1.1 |
| 潘星宇 | 2017-11-12 | 添加commoditydata模块 | v1.1 |
| 潘星宇 | 2017-11-12 | 添加userdata模块 | v1.1 |
| 孙嘉杰 | 2017-11-12 | 修改promotionbl模块 | v1.2 |

>>>>>>> refs/remotes/origin/master


## 1.引言
<br/>
　　**1.1　编制目的**

　　本报告详细完成对企业进销存系统的详细设计，达到指导后续软件构造的目的，同时实现和测试人员及用户的沟通。

　　本报告面向开发人员、测试人员及最终用户而编写，是了解系统的导航。

　　**1.2　词汇表**

|词汇名称|词汇含义|备注|
| --- | --- | --- |
|SIMS|企业进销存系统|……|
<br/>
　　**1.3　参考资料**

## 2.产品概述
<br/>
　　参考企业进销存系统用例文档和企业进销存系统软件需求规格说明文档中对产品的概括描述。

## 3.体系结构设计概述
<br/>
　　参考企业进销存系统概要设计文档中对体系结构设计的概述。

## 4.结构视角
<br/>
　　**4.1　业务逻辑层的分解**

　　业务逻辑层的开发包图参见软件体系结构文档图。

　　　　4.1.1　accountbl模块

　　　　(1)模块概述

　　　　accountbl模块承担的需求参见需求规格说明文档功能需求几相关非功能需求。
　　　　Accountbl模块的职责及接口参见软件体系结构描述文档表。

　　　　(2)整体结构

　　　　根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加businesslogicservice.accountblservice.AccountBLService接口。业务逻辑层和数据层之间添加dataservice.accountdataservice.AccountDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了AccountController，这样AccountController将会对账户管理的业务逻辑处理委托给Account对象。AccountPO是作为账户记录的持久化对象被添加到设计模型中去的。

　　　　accountbl模块的设计如图所示。

<img src="../img/软件详细设计图/accountbl模块设计图.png">

　　accountbl模块各个类的职责如下所示

|模块|职责|
| --- | --- |
|AccountController|负责实现账户管理界面所需要的服务|
|AccountBL|账户管理的领域模型对象|

　　　　(3)模块内部类的接口规范

　　　AccountController的接口规范

|提供的服务|供接口||
| --- | --- | --- |
|**AccountController.startManage**|语法|public ResultMessage startManage()|
||前置条件|已创建一个AccountBL对象，并且输入符合规则|
||后置条件|调用AccountBL领域对象的startManage方法|
|**AccountController.find**|语法|public AccoutPO find(String message)|
||前置条件|已创建一个AccountBL对象，并且输入符合规则|
||后置条件|调用AccountBL领域对象的check方法|
|**AccountController.newBuild**|语法|public ResultMessage newBuild(AccountVO accountVO)|
||前置条件|已创建一个AccountBL对象，并且输入符合规则|
||后置条|调用AccountBL领域对象的newBuild方法|
|**AccountController.delete**|语法|public ResultMessage delete(AccountVO accountVO)|
||前置条件|已创建一个AccountBL对象，并且输入符合规则|
||后置条件|调用AccountBL领域对象的delete方法|
|**AccountController.modify**|语法|public ResultMessage modify(AccountVO accountVO)|
||前置条件|已创建一个AccountBL对象，并且输入符合规则|
||后置条件|调用AccountBL领域对象的modify方法|　
<br/>

|需要的服务|需接口|
| --- | --- |
|服务名|服务|
|AccountBL.find(string message)|根据查找内容查找账户|
|AccountBL.newBuild(AccountVO accountVO)|添加账户|
|AccountBL.delete(AccountVO accountVO)|删除账户|
|AccountBL.modify(AccountVO accountVO)|修改账户|
<br/>
　　　AccountBL的接口规范

|提供的服务|供接口||
| --- | --- | --- |
|**AccountBL.startManage**|语法|public ResultMessage startManage()|
||前置条件|用户已经登录|
||后置条件|根据判断结果决定是否允许使用此功能|
|**AccountBL.find**|语法|public AccoutVO find(String message)|
||前置条件|已输入正确的搜素关键词|
||后置条件|返回查找到的账户列表|
|**AccountBL.newBuild**|语法|public ResultMessage newBuild(AccountVO accountVO)|
||前置条件|已输入正确的账户格式|
||后置条件|持久化更新数据并返回消息|
|**AccountBL.delete**|语法|public ResultMessage delete(AccountVO accountVO)|
||前置条件|存在选中的待删除的银行账户|
||后置条件|持久化更新数据并返回消息|
|**AccountBL.modify**|语法|public ResultMessage modify(AccountVO accountVO)|
||前置条件|选中一个待修改的银行账户且输入内容正确|
||后置条件|持久化更新数据并返回消息|
<br/>　

|需要的服务|需接口|
| --- | --- |
|服务名|服务|
|AccountDataService.find(String message)|根据信息查找多个持久化对象|
|AccountDataService.newBuild(AccountVO accountVO)|新建单一持久化对象|
|AccountDataService.delete(AccountVO accountVO)|删除单一持久化对象|
|AccountDataService.modify(AccountVO accountVO)|更新单一持久化对象|
|DatabaseFactory.getAccountDatabase|得到Account数据库的服务的引用|



　　　　(4)业务逻辑层的动态模型

　　　　以下四个图分别表明了企业进销存系统中，对银行账户进行增删改查的逻辑处理的相关对象之间的协作

<img src="../img/软件详细设计图/account_add顺序图.png">

<img src="../img/软件详细设计图/account_delete顺序图.png">

<img src="../img/软件详细设计图/account_modify顺序图.png">

<img src="../img/软件详细设计图/account_find顺序图.png">


 　　　　**4.1.2　mfdocbl模块**

　　　　(1)模块概述

　　　　mfdocbl模块承担的需求参见需求规格说明文档功能需求几相关非功能需求。
　　　　MFDocbl模块的职责及接口参见软件体系结构描述文档表。

　　　　(2)整体结构

　　　　根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加businesslogicservice.mfdocblservice.MFDocBLService接口。业务逻辑层和数据层之间添加dataservice.mfdocdataservice.MFDocDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了MFDocController，这样MFDocController将会对账户管理的业务逻辑处理委托给MFDoc对象。

　　　　mfdocbl模块的设计如图所示。

<img src="../img/软件详细设计图/accountbl模块设计图.png">

　　mfdocbl模块各个类的职责如下所示

|模块|职责|
| --- | --- |
|SKDController|负责实现收款单界面所需要的服务|
|XJFYDController|负责实现现金费用单界面所需要的服务|
|SKDBL|收款单的领域模型对象|
|XJFYDBL|现金费用单的领域模型对象|

　　　　(3)模块内部类的接口规范

　　　　SKDController的接口规范

|提供的服务|供接口||
| --- | --- | --- |
|**SKDController.newBuild**|语法|public ResultMessage newBuild(SKDVO skdVO)|
||前置条件|已经创建一个SKDBL领域对象|
||后置条件|调用SKDBL领域对象的newBuild方法|
|**SKDController.modify**|语法|public ResultMessage modify(SKDVO skdVO)|
||前置条件|已经创建一个SKDBL领域对象|
||后置条件|调用SKDBL领域对象的modify方法|
|**SKDController.delete**|语法|public ResultMessage delete(SKDVO skdVO)|
||前置条件|已经创建一个SKDBL领域对象|
||后置条件|调用SKDBL领域对象的delete方法|
|**SKDController.find**|语法|public SKDVO find(String message)|
||前置条件|已经创建一个SKDBL领域对象|
||后置条件|调用SKDBL领域对象的find方法|
|**SKDController.commit**|语法|public ResultMessage commit(SKDVO skdVO)|
||前置条件|已经创建一个SKDBL领域对象|
||后置条件|调用SKDBL领域对象的commit方法|
<br/>

|需要的服务|需接口|
| --- | --- |
|服务名|服务|
|SKDBL.find(string message)|根据查找内容查找单据|
|SKDBL.newBuild(SKDVO skdVO)|添加单据|
|SKDBL.delete(SKDVO skdVO)|删除单据|
|SKDBL.modify(SKDVO skdVO)|修改单据|
|SKDBL.commit(SKDVO skdVO)|提交单据|
<br/>
　　　　SKDBL的接口规范

|提供的服务|供接口||
| --- | --- | --- |
|**SKDBL.newBuild**|语法|public ResultMessage newBuild(SKDVO skdVO)|
||前置条件|输入正确的收款单单据内容|
||后置条件|新建一个收款单单据并返回消息|
|**SKDBL.modify**|语法|public ResultMessage modify(SKDVO skdVO)|
||前置条件|选中一个收款单单据且输入内容正确|
||后置条件|持久化更新数据并返回消息|
|**SKDBL.delete**|语法|public ResultMessage delete(SKDVO skdVO)|
||前置条件|存在选中的待删除单据|
||后置条件|删除所选中的单据并返回消息|
|**SKDBL.find**|语法|public SKDVO find(String message)|
||前置条件|已输入正确的搜索关键词|
||后置条件|返回查找到的单据列表|
|**SKDBL.commit**|语法|public ResultMessage commit(SKDVO skdVO)|
||前置条件|选中待提交的单据|
||后置条件|将单据提交至总经理，修改单据状态属性并返回消息|
<br/>

|需要的服务|需接口|
| --- | --- |
|服务名|服务|
|SKDDataService.find(String message)|根据信息查找多个持久化对象|
|SKDDataService.newBuild()|新建单一持久化对象|
|SKDDataService.delete(SKDVO skdVO)|删除单一持久化对象|
|SKDDataService.modify(SKDVO skdVO)|更新单一持久化对象|
|SKDDataService.commit(SKDVO skdVO)|更新单一持久化对象|
|DatabaseFactory.getSKDDatabase|得到SKD数据库的服务的引用|
<br/>

　　　　XJFYDController的接口规范

|提供的服务|供接口||
| --- | --- | --- |
|**XJFYDController.newBuild**|语法|public ResultMessage newBuild(XJFYDVO xjfydVO)|
||前置条件|已经创建一个XJFYDBL领域对象|
||后置条件|调用XJFYDBL领域对象的newBuild方法|
|**XJFYDController.modify**|语法|public ResultMessage modify(XJFYDVO xjfydVO)|
||前置条件|已经创建一个XJFYDBL领域对象|
||后置条件|调用XJFYDBL领域对象的modify方法|
|**XJFYDController.delete**|语法|public ResultMessage delete(XJFYDVO xjfydVO)|
||前置条件|已经创建一个XJFYDBL领域对象|
||后置条件|调用XJFYDBL领域对象的delete方法|
|**XJFYDController.find**|语法|public XJFYDVO find(String message)|
||前置条件|已经创建一个XJFYDBL领域对象|
||后置条件|调用XJFYDBL领域对象的find方法|
|**XJFYDController.commit**|语法|public ResultMessage commit(XJFYDVO xjfydVO)|
||前置条件|已经创建一个XJFYDBL领域对象|
||后置条件|调用XJFYDBL领域对象的commit方法|
<br/>

|需要的服务|需接口|
| --- | --- |
|服务名|服务|
|XJFYDBL.find(string message)|根据查找内容查找单据|
|XJFYDBL.newBuild(XJFYDVO xjfydVO)|添加单据|
|XJFYDBL.delete(XJFYDVO xjfydVO)|删除单据|
|XJFYDBL.modify(XJFYDVO xjfydVO)|修改单据|
|XJFYDBL.commit(XJFYDVO xjfydVO)|提交单据|
<br/>
　　　　XJFYDBL的接口规范

|提供的服务|供接口||
| --- | --- | --- |
|**XJFYDBL.newBuild**|语法|public ResultMessage newBuild(XJFYDVO xjfydVO)|
||前置条件|输入正确的收款单单据内容|
||后置条件|新建一个收款单单据并返回消息|
|**XJFYDBL.modify**|语法|public ResultMessage modify(XJFYDVO xjfydVO)|
||前置条件|选中一个收款单单据且输入内容正确|
||后置条件|持久化更新数据并返回消息|
|**XJFYDBL.delete**|语法|public ResultMessage delete(XJFYDVO xjfydVO)|
||前置条件|存在选中的待删除单据|
||后置条件|删除所选中的单据并返回消息|
|**XJFYDBL.find**|语法|public XJFYDVO find(String message)|
||前置条件|已输入正确的搜索关键词|
||后置条件|返回查找到的单据列表|
|**XJFYDBL.commit**|语法|public ResultMessage commit(XJFYDVO xjfydVO)|
||前置条件|选中待提交的单据|
||后置条件|将单据提交至总经理，修改单据状态属性并返回消息|
<br/>

|需要的服务|需接口|
| --- | --- |
|服务名|服务|
|XJFYDDataService.find(String message)|根据信息查找多个持久化对象|
|XJFYDDataService.newBuild()|新建单一持久化对象|
|XJFYDDataService.delete(XJFYDVO xjfydVO)|删除单一持久化对象|
|XJFYDDataService.modify(XJFYDVO xjfydVO)|更新单一持久化对象|
|XJFYDDataService.commit(XJFYDVO xjfydVO)|更新单一持久化对象|
|DatabaseFactory.getXJFYDDatabase|得到XJFYD数据库的服务的引用|
<br/>

　　　　(4)业务逻辑层的动态模型

　　　　以下图分别表明了企业进销存系统中，对收款单和现金费用单进行增、删、改、查、提交等逻辑处理的相关对象之间的协作

<img src="../img/软件详细设计图/account_add顺序图.png">

<img src="../img/软件详细设计图/account_delete顺序图.png">

<img src="../img/软件详细设计图/account_modify顺序图.png">

<img src="../img/软件详细设计图/account_find顺序图.png">

　　　　**4.1.3　setupaccountbl模块**

　　　　(1)模块概述

　　　　setupaccountbl模块承担的需求参见需求规格说明文档功能需求几相关非功能需求。
　　　　SetUpAccountbl模块的职责及接口参见软件体系结构描述文档表。

　　　　(2)整体结构

　　　　根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加businesslogicservice.setupaccountblservice.SetUpAccountBLService接口。业务逻辑层和数据层之间添加dataservice.setupaccountdataservice.SetUpAccountDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了SetUpAccountController，这样SetUpAccountController将会对期初建账的业务逻辑处理委托给SetUpAccount对象。AccountBookPO是作为期初建账后账簿的持久化对象被添加到设计模型中去的。

　　　　setupaccountbl模块的设计如图所示。

<img src="../img/软件详细设计图/setupaccount模块设计图.png">

　　setupaccountbl模块各个类的职责如下所示

|模块|职责|
| --- | --- |
|SetUpAccountController|负责实现期初建账界面所需要的服务|
|SetUpAccountBL|期初建账的领域模型对象|

　　　　(3)模块内部类的接口规范

　　　SetUpAccountController的接口规范

|提供的服务|供接口||
| --- | --- | --- |
|**SetUpAccountController.newBuild**|语法|public ResultMessage newBuild(AccountBookVO accountBookVO)|
||前置条件|已创建一个SetUpAccountBL对象，并且输入符合规则|
||后置条件|调用AccountBL领域对象的newBuild方法|
|**SetUpAccountController.delete**|语法|public ResultMessage delete(AccountBookVO accountBookVO)|
||前置条件|已经创建一个SetUpAccountBL对象|
||后置条件|调用SetUpAccountBL领域对象的delete方法|
|**SetUpAccountController.find**|语法|public AccountBookVO find()|
||前置条件|已经创建一个SetUpAccountBL对象|
||后置条件|调用SetUpAccountBL领域对象的find方法|
<br/>　

|需要的服务|需接口|
| --- | --- |
|服务名|服务|
|SetUpAccountBL.newBuild(AccountBookVO AccountBookVO)|添加账簿|
|SetUpAccountBL.delete(AccountBookVO accountBookVO)|删除账簿|
|SetUpAccountBL.find()|查找所有的账簿|
<br/>
　　　SetUpAccountBL的接口规范

|提供的服务|供接口||
| --- | --- | --- |
|**SetUpAccountController.newBuild**|语法|public ResultMessage newBuild(AccountBookVO accountBookVO)|
||前置条件|输入正确的期初建账内容|
||后置条件|新建账簿并返回消息|
|**SetUpAccountController.delete**|语法|public ResultMessage delete(AccountBookVO accountBookVO)|
||前置条件|存在所选中的待删除账簿|
||后置条件|删除账簿并返回消息|
|**SetUpAccountController.find**|语法|public AccountBookList find()|
||前置条件|需要查找所有账簿|
||后置条件|返回所有账簿的列表|
<br/>　

|需要的服务|需接口|
| --- | --- |
|服务名|服务|
|SetUpAccountDataService.find()|查找多个持久化对象|
|SetUpAccountDataService.newBuild(AccountBookVO accountBookVO)|新建单一持久化对象|
|SetUpAccountDataService.delete(AccountBookVO accountBookVO)|删除单一持久化对象|
|DatabaseFactory.getAccountBookDatabase|得到AccountBook数据库的服务的引用|



　　　　(4)业务逻辑层的动态模型

　　　　以下三个图分别表明了企业进销存系统中，对账簿进行增删查的逻辑处理的相关对象之间的协作

<img src="../img/软件详细设计图/setupaccount_newBuild顺序图.png">

<img src="../img/软件详细设计图/setupaccount_delete顺序图.png">

<img src="../img/软件详细设计图/setupaccount_find顺序图.png">

4.1.4 commoditybl 模块<br>
（1）模块概述<br>
commoditybl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br>
commoditybl模块的职责及接口参见软件系统结构描述文档表<br>
 （2）整体结构<br>
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加bussinesslogicservice.commodityblservice.CommodityBLService接口和bussinesslogicservice.commodityblservice.ClassificationBLService接口。业务逻辑层和数据层之间添加dataservice.commoditydataservice.CommodityDataService接口和dataservice.commoditydataservice.ClassificationDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了CommodityController，这样CommodityController会将对商品的业务逻辑处理委托给Commodity对象。CommodityPO和ClassificationPO是作为商品及其分类记录的持久化对象添加到设计模型中去的。而CommodityList和CommodityItem的添加时Billinfo的容器类。CommodityItem保有具体商品的数据，及相应的计算小计的职责。而Classification是作为商品的分类而聚合在其中。CommodityList封装了关于Commodity的数据集合的数据结构的秘密和计算总数的职责。Salesinfo和Billinfo是根据依赖倒置原则，为了消除循环依赖而产生的接口。<br>
<img src="../img/软件详细设计图/commodity模块各个类的设计.png"><br>
<center>**commodity模块各个类的设计**</center>
<table><tbody>
<tr>
<th>模  块</th>
<th>职  责</th>
</tr>
<tr>
<th>CommodityController</th>
<th>负责实现商品界面所需要的服务</th>
</tr>
<tr>
<th>Commodity</th>
<th>商品的领域模型对象，拥有一个商品所持有的数量、售价等信息，可以帮助完成商品界面所需要的服务</th>
</tr>
<tr>
<th>CommodityList</th>
<th>商品清单的领域模型对象，拥有一系列商品所持有的数量、售价等信息，可以帮助完成商品界面所需要的服务</th>
</tr>
<tr>
<th>CommodityItem</th>
<th>商品项目的领域模型对象，拥有具体商品所持有的批次、售价等信息，可以帮助完成商品界面所需要的服务</th>
</tr>
<tr>
<th>Classification</th>
<th>商品分类的领域模型对象，拥有一个商品分类所持有的下属商品等信息，可以帮助完成商品界面所需要的服务</th>
</tr>
</table>

（3）模块内部类的接口规范
<center>**CommodityController的接口规范**</center>
<table><tbody>
<tr>
<th colspan = "3">提供的服务（供接口）</th>
</tr>
<tr>
<th rowspan="3">CommodityController.addBill</th>
<th>语法</th>
<th>public ResultMessage addBill(CommodityPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Commodity领域对象，并且输入符合输入规则</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Commodity领域对象的addBill方法</th>
</tr>
<tr>
<th rowspan="3">CommodityController.addSales</th>
<th>语法</th>
<th>public ResultMessage addSales(CommodityPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Commodity领域对象，并且输入符合输入规则</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Commodity领域对象的addSales方法</th>
</tr>
<tr>
<th rowspan="3">CommodityController.getTotal</th>
<th>语法</th>
<th>public ResultMessage getTotal(CommodityPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Commodity领域对象，已添加商品和数量，并且输入符合输入规则</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Commodity领域对象的getTotal方法</th>
</tr>
</table>

<center>**Commodity的接口规范**</center>
<table><tbody>
<tr>
<th colspan="3">提供的服务（供接口）</th>
</tr>
<tr>
<th rowspan="3">Commodity.addBill</th>
<th>语法</th>
<th>public ResultMessage addBill(CommodityPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>启动一个商品增减回合</th>
</tr>
<tr>
<th>后置条件</th>
<th>在一个商品增加回合中，生成一个单据</th>
</tr>
<tr>
<th rowspan="3">Commodity.addSales</th>
<th>语法</th>
<th>public ResultMessage addSales(CommodityPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>启动一个商品增减回合</th>
</tr>
<tr>
<th>后置条件</th>
<th>在一个商品增加回合中，生成一次销售记录</th>
</tr>
<tr>
<th rowspan="3">Commodity.getTotal</th>
<th>语法</th>
<th>public ResultMessage getTotal(CommodityPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>已进行一次商品的增减</th>
</tr>
<tr>
<th>后置条件</th>
<th>返回商品数量的总数</th>
</tr>
</table>
<table><tbody>
<tr>
<th colspan = "2">需要的服务（需接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>CommodityDataService.find(long id)</th>
<th>根据ID进行查找单一持久化对象</th>
</tr>
<tr>
<th>CommodityDataService.finds(String field,int value)</th>
<th>根据字段名和值查找多个持久化对象</th>
</tr>
<tr>
<th>CommodityDataService.insert(CommodityPO po)</th>
<th>插入单一持久化对象</th>
</tr>
<tr>
<th>CommodityDataService.delete(CommodityPO po)</th>
<th>删除单一持久化对象</th>
</tr>
<tr>
<th>CommodityDataService.update(CommodityPO po)</th>
<th>更新单一持久化对象</th>
</tr>
<th>DataFactory.getCommodityDatabase</th>
<th>得到Commodity数据库的服务的引用</th>
</tr>
</table>


<center>**CommodityList的接口规范**</center>
<table><tbody>
<tr>
<th colspan = "2">需要的服务（需接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>CommodityDataService.check(CommodityList list)</th>
<th>查看库存中的一段时间的对象</th>
</tr>
<tr>
<th>CommodityDataService.stock(CommodityList list)</th>
<th>查看库存中的给定要求的商品对象</th>
</tr>
<tr>
</table>

<center>**Classification的接口规范**</center>
<table><tbody>
<tr>
<th colspan = "2">需要的服务（需接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>ClassDataService.insertClass(ClassificationPO po)</th>
<th>插入单一持久化对象</th>
</tr>
<tr>
<th>ClassDataService.deleteClass(ClassificationPO po)</th>
<th>删除单一持久化对象</th>
</tr>
<tr>
<th>ClassDataService.updateClass(ClassificationPO po)</th>
<th>更新单一持久化对象</th>
</tr>
<tr>
<th>DataFactory.getClassDatabase</th>
<th>得到Class数据库的服务的引用</th>
</tr>
</table>

（4）业务逻辑层的动态模型
该图表明了SIMS系统中，当用户点击输入新增添的商品之后，商品业务逻辑处理相关对象之间的协作<br>
<img src="../img/软件详细设计图/添加商品的顺序图.png"><br>
该图表明了SIMS系统中，当用户点击输入删除的商品之后，商品业务逻辑处理相关对象之间的协作<br>
<img src="../img/软件详细设计图/删除商品的顺序图.png"><br>
该图表明了SIMS系统中，当用户点击输入修改的商品之后，商品业务逻辑处理相关对象之间的协作<br>
<img src="../img/软件详细设计图/修改商品的顺序图.png"><br>
该图表明了SIMS系统中，当用户点击输入查询商品之后，商品业务逻辑处理相关对象之间的协作<br>
<img src="../img/软件详细设计图/查询商品的顺序图.png"><br>
该图表明了SIMS系统中，当用户点击输入新增添的分类之后，商品分类业务逻辑处理相关对象之间的协作<br>
<img src="../img/软件详细设计图/添加分类的顺序图.png"><br>
该图表明了SIMS系统中，当用户点击输入删除的分类之后，商品分类业务逻辑处理相关对象之间的协作<br>
<img src="../img/软件详细设计图/删除分类的顺序图.png"><br>
该图表明了SIMS系统中，当用户点击输入修改的分类之后，商品分类业务逻辑处理相关对象之间的协作<br>
<img src="../img/软件详细设计图/修改分类的顺序图.png"><br>

4.1.5 userbl 模块<br>
（1）模块概述<br>
userbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br>
userbl模块的职责及接口参见软件系统结构描述文档表<br>
（2）整体结构<br>
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加bussinesslogicservice.userblservice.UserBLService接口。业务逻辑层和数据层之间添加dataservice.userdataservice.UserDataService接口。UserPO是作为商品记录的持久化对象添加到设计模型中去的。<br>
<img src="../img/软件详细设计图/userbl模块各个类的设计.png"><br>
<center>**user模块各个类的设计**</center>
<table><tbody>
<tr>
<th>模  块</th>
<th>职  责</th>
</tr>
<tr>
<th>LoginController</th>
<th>负责实现对应于登录界面所需要的服务</th>
</tr>
<th>User</th>
<th>系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登录问题</th>
</tr>
</table>
（3）模块内部类的接口规范
<center>**User的接口规范**</center>
<table><tbody>
<tr>
<th colspan = "3">提供的服务（供接口）</th>
</tr>
<tr>
<th rowspan="3">user.getAuthority</th>
<th>语法</th>
<th>public ResultMessage getAuthority()</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个user领域对象，并且其权限已被赋值</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用User领域对象的getAuthority方法</th>
</tr>
<tr>
<th rowspan="3">user.getRole</th>
<th>语法</th>
<th>public ResultMessage getRole()</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个user领域对象，并且其角色已被确认</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用User领域对象的getRole方法</th>
</tr>
</table>

<table><tbody>
<tr>
<th colspan = "2">需要的服务（需接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>UserDataService.find(long id)</th>
<th>根据ID进行查找单一持久化对象</th>
</tr>
<tr>
<th>UserDataService.insert(UserPO po)</th>
<th>插入单一持久化对象</th>
</tr>
<tr>
<th>UserDataService.delete(UserPO po)</th>
<th>删除单一持久化对象</th>
</tr>
<tr>
<th>UserDataService.update(UserPO po)</th>
<th>更新单一持久化对象</th>
</tr>
<tr>
<th>DataFactory.getUserDatabase</th>
<th>得到User数据库的服务的引用</th>
</tr>
</table>

（4）业务逻辑层的动态模型
该图表明了SIMS系统中，当用户点击输入新增添的用户之后，商品业务逻辑处理相关对象之间的协作<br>
<img src="../img/软件详细设计图/添加用户的顺序图.png"><br>
该图表明了SIMS系统中，当用户点击输入删除的用户之后，商品业务逻辑处理相关对象之间的协作<br>
<img src="../img/软件详细设计图/删除用户的顺序图.png"><br>
该图表明了SIMS系统中，当用户点击输入修改的用户之后，商品业务逻辑处理相关对象之间的协作<br>
<img src="../img/软件详细设计图/修改用户的顺序图.png"><br>
该图表明了SIMS系统中，当用户点击输入查询用户之后，商品业务逻辑处理相关对象之间的协作<br>
<img src="../img/软件详细设计图/查询用户的顺序图.png"><br>


4.1.6 salesbl 模块<br>
（1）模块概述<br>
salesbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br>
salesbl模块的职责及接口参见软件系统结构描述文档表<br>

（2）整体结构<br>
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加bussinesslogicservice. SaleBLService接口。业务逻辑层和数据层之间添加dataservice. SaleDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了SaleController，这样SaleController会将对销售的逻辑业务处理委托给Sale对象。SalePO是作为销售单的持久化对象被添加到设计模型中去的。<br>

Salebl模块的设计如图所示<br>

<img src="../img/软件详细设计图/Sales模块.png"><br>

salesbl模块各个类的职责<br>

| **模块** | **职责** |
| ------- | --------- |
| LoginController | 负责实现对应于登录界面所需要的服务 |
| SalesController | 负责实现销售管理界面所需要的服务 |
| Sales | 制定销售单的领域模型对象，拥有销售单的信息 |
| user | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登录问题 |
| SalesList | 每一个销售单的数据信息 |
| SaleslineItem | 销售单数据里面的条目 |

（3）模块内部类的接口规范<br>
<center>**SalesController的接口规范**</center>
<table><tbody>
<tr>
<th colspan = "3">提供的服务（供接口）</th>
</tr>
<tr>
<th rowspan="3">SalesController.getSalesID</th>
<th>语法</th>
<th>public String getSalesID()</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Sale领域对象，并且输入符合输入规则</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Sale的方法</th>
</tr>
<tr>
<th rowspan="3">SalesController.getSaleBackID</th>
<th>语法</th>
<th>public String getSaleBackID()</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Sale领域对象，并且输入符合输入规则</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Sales领域对象的方法</th>
</tr>
<tr>
<th rowspan="3">SalesController.addCommodities</th>
<th>语法</th>
<th>public void addCommodities(CommodityItem item)</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Sale领域对象，添加商品和数量，并且输入符合输入规则</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Sale领域对象的addCommodities方法</th>
</tr>
<tr>
<th rowspan="3">SalesController.deteleCommodities</th>
<th>语法</th>
<th>public void deleteCommodities(CommodityPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Sale领域对象，删除商品，并且输入符合输入规则</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Sale领域对象的deleteCommodities方法</th>
</tr>
<tr>
<th rowspan="3">SalesController.findCommodities</th>
<th>语法</th>
<th>public void findCommodities(CommodityPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Sale领域对象，查找商品与其数量，并且输入符合输入规则</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Sale领域对象的findCommodities方法</th>
</tr>
<tr>
<th rowspan="3">SalesController.updateCommodities</th>
<th>语法</th>
<th>public void updateCommodities(CommodityItem item)</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Sale领域对象，修改商品和数量，并且输入符合输入规则</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Sale领域对象的updateCommodities方法</th>
</tr>
<tr>
<th rowspan="3">SalesController.getTotal</th>
<th>语法</th>
<th>public double getTotal()</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Sale领域对象，已计算总额</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Sale领域对象的getTotal方法</th>
</tr>
<tr>
<th rowspan="3">SalesController.save</th>
<th>语法</th>
<th>public ResultMessage save()</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Sale领域对象</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Sale领域对象的方法</th>
</tr>
<tr>
<th rowspan="3">SalesController.submit</th>
<th>语法</th>
<th>public ResultMessage submit()</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Sale领域对象</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Sale领域对象的方法</th>
</tr>
</table>

<table><tbody>
<tr>
<th colspan = "2">需要的服务（需接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>Sales.getSalesID</th>
<th>获取销售单的ID</th>
</tr>
<tr>
<th>Sales.getSaleBackID</th>
<th>获取销售退货单的ID</th>
</tr>
<tr>
<th>salesDataService.addCommodities(CommodityPO po)</th>
<th>添加商品</th>
</tr>
<tr>
<th>SalesDataService.deleteCommodities(CommodityPO po)</th>
<th>删除商品</th>
</tr>
<tr>
<th>SalesDataService.updateCommodities(CommodityPO po)</th>
<th>修改商品</th>
</tr>
<tr>
<tr>
<th>Sales.save</th>
<th>保存草稿</th>
</tr>
<th>Sales.submit</th>
<th>提交单据</th>
</tr>
</table>


<center>**Sales的接口规范**</center>
<table><tbody>
<tr>
<th colspan="3">提供的服务（供接口）</th>
</tr>
<tr>
<th rowspan="3">Sales.findCommodities</th>
<th>语法</th>
<th>public ResultMessage findCommodities(String id)</th>
</tr>
<tr>
<th>前置条件</th>
<th>启动一个销售回合</th>
</tr>
<tr>
<th>后置条件</th>
<th>在一个销售回合中，查找一个目标商品</th>
</tr>

<tr>
<th rowspan="3">Sales.addCommodities</th>
<th>语法</th>
<th>public ResultMessage addCommodities(CommodityPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>启动一个销售回合</th>
</tr>
<tr>
<th>后置条件</th>
<th>在一个销售回合中，添加一个商品</th>
</tr>
<tr>
<th rowspan="3">Sales.deleteCommodities</th>
<th>语法</th>
<th>public ResultMessage deleteCommodities(CommodityPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>启动一个销售回合</th>
</tr>
<tr>
<th>后置条件</th>
<th>在一个销售回合中，删除一个商品</th>
</tr>
<tr>
<th rowspan="3">Sales.updeteCommodities</th>
<th>语法</th>
<th>public ResultMessage updeteCommodities(CommodityPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>启动一个销售回合</th>
</tr>
<tr>
<th>后置条件</th>
<th>在一个销售回合中，修改一个商品的属性，如数量</th>
</tr>
<tr>
<th rowspan="3">Sales.getTotal</th>
<th>语法</th>
<th>public ResultMessage getTotal(CommodityPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>已完成一次销售(退货)单的制定</th>
</tr>
<tr>
<th>后置条件</th>
<th>返回此销售回合中的总额</th>
</tr>
</table>

<table><tbody>
<tr>
<th colspan = "2">需要的服务（需接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>SalesDataService.findCommodities(String id)</th>
<th>根据ID进行查找单一持久化对象</th>
</tr>
<tr>
<th>SalesDataService.finds(String field,int value)</th>
<th>根据字段名和值查找多个持久化对象</th>
</tr>
<tr>
<th>SalesDataService.insert(CommodityPO po)</th>
<th>增加单一持久化对象</th>
</tr>
<tr>
<th>SalesDataService.delete(CommodityPO po)</th>
<th>删除单一持久化对象</th>
</tr>
<tr>
<th>SalesDataService.update(CommodityPO po)</th>
<th>更新单一持久化对象</th>
</tr>
<tr>
<th>DataFactory.getSalesDatabase</th>
<th>得到Sales数据库的服务的引用</th>
</tr>
</table>

（4）业务逻辑层的动态模型<br>

该图展示了进货销售人员想在销售单／销售退货单中添加一个商品的时候，销售业务逻辑处理的相关对象之间的协作<br>
<img src="../img/软件详细设计图/addCommodity.png">


该图展示了进货销售人员对一个销售单／销售退货单进行提交审批时，销售业务逻辑处理的相关对象之间的协作<br>
<img src="../img/软件详细设计图/submitSales.png">


该图展示了进货销售人员对一个销售单／销售退货单进行保存草稿时，销售业务逻辑处理的相关对象之间的协作<br>
<img src="../img/软件详细设计图/saveSales.png">


该图所示的状态图描述了Sales对象的生存期间的状态序列、引起转移的事件，以及因状态转移而伴随的动作<br>
<img src="../img/软件详细设计图/Sales对象状态图.png">


 (5)业务逻辑层的设计原理<br>
利用委托式风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

4.1.7 memberbl 模块<br>
（1）模块概述<br>
memberbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br>
memberbl模块的职责及接口参见软件系统结构描述文档表<br>

（2）整体结构<br>
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加bussinesslogicservice. MemberBLService接口。业务逻辑层和数据层之间添加dataservice. MemberDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了MemberController，这样MemberController会将对客户的逻辑业务处理委托给Member对象。MemberPO是作为客户的持久化对象被添加到设计模型中去的<br>

Memberbl模块的设计如图<br>

<img src="../img/软件详细设计图/Member模块各个类的设计.png">

<center>**member模块各个类的设计**</center>

| **模块** | **职责** |
|---------| -----------|
| MemberController | 负责实现客户管理界面所需要的服务 |
| Member | 客户管理的领域模型对象，拥有客户数据的编号、分类、级别、姓名、电话、地址、邮编、电子邮箱、应收额度、应收、应付、默认业务员 |
| user | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登录问题 |


（3）模块内部类的接口规范<br>

<center>**Member的接口规范**</center>
<table><tbody>
<tr>
<th colspan="3">提供的服务（供接口）</th>
</tr>
<tr>
<th rowspan="3">Member.findMember</th>
<th>语法</th>
<th>public ResultMessage findMember(String keywords, string id)</th>
</tr>
<tr>
<th>前置条件</th>
<th>关键字符合输入条件，id符合输入条件</th>
</tr>
<tr>
<th>后置条件</th>
<th>查询到目标客户</th>
</tr>
<tr>
<th rowspan="3">Member.addMember</th>
<th>语法</th>
<th>public ResultMessage addMember(MemberPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>类型、名字、级别、电话、地址、邮编等符合输入条件</th>
</tr>
<tr>
<th>后置条件</th>
<th>成功添加客户，持久化更新客户的数据</th>
</tr>
<tr>
<th rowspan="3">Member.updateMember</th>
<th>语法</th>
<th>public ResultMessage upddteMember(MemberPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>修改的属性符合输入条件</th>
</tr>
<tr>
<th>后置条件</th>
<th>客户属性被成功修改，持久化更新客户的数据</th>
</tr>
<tr>
<th rowspan="3">Member.deleteMember</th>
<th>语法</th>
<th>public ResultMessage deleteMember(String name)</th>
</tr>
<tr>
<th>前置条件</th>
<th>输入的客户符合输入条件</th>
</tr>
<tr>
<th>后置条件</th>
<th>客户被成功删除，持久化更新客户的数据</th>
</tr>
</table>
<table><tbody>

<table><tbody>
<tr>
<th colspan = "2">需要的服务（需接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>MemberDataService.findMember(String id)</th>
<th>根据ID进行查找单一持久化对象</th>
</tr>
<tr>
<th>MemberDataService.addMember(MemberPO po)</th>
<th>添加单一持久化对象</th>
</tr>
<tr>
<th>MemberDataService.deleteMember(MemberPO po)</th>
<th>删除单一持久化对象</th>
</tr>
<tr>
<th>MemberDataService.updateMember(MemberPO po)</th>
<th>更改单一持久化对象</th>
</tr>
<tr>
<th>MemberDataService.getMemberDatebase</th>
<th>得到Member数据库的服务的引用</th>
</tr>
</table>

（4）业务逻辑层的动态模型<br>

该图展示了当进货销售人员想要添加一个客户的时候，客户管理业务逻辑处理的相关对象之间的协作<br>
<img src="../img/软件详细设计图/addMember.png">


该图展示了当进货销售人员想要删除一个客户的时候，客户管理业务逻辑处理的相关对象之间的协作<br>
<img src="../img/软件详细设计图/deleteMember.png">


该图所示的状态图描述了Member对象的生存期间的状态序列、引起转移的事件，以及因状态转移而伴随的动作。
<img src="../img/软件详细设计图/Member对象状态图.png">


 (5)业务逻辑层的设计原理<br>
利用委托式风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

4.1.8 purchasebl 模块<br>
（1）模块概述<br>
purchasebl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br>
purchasebl模块的职责及接口参见软件系统结构描述文档表<br>

（2）整体结构<br>
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加bussinesslogicservice. PurchaseBLService接口。业务逻辑层和数据层之间添加dataservicePurchaseDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了PurchaseController，这样PurchaseController会将对进货的逻辑业务处理委托给Purchase对象。PurchasePO是作为进货单的持久化对象被添加到设计模型中去的<br>

如图展示了Purchaseb模块的设计<br>
<img src="../img/软件详细设计图/Purchase模块.png">


Purchasebl各个类的职责如图<br>

| **模块** | **职责** |
| ------- | --------- |
| LoginController | 负责实现对应于登录界面所需要的服务 |
| PurchaseController | 负责实现进货管理界面所需要的服务 |
| Purchase | 制定进货单的领域模型对象，拥有进货单的信息 |
| user | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登录问题 |
| PurchaseList | 每一个进货单的数据信息 |
| PurchaseLineItem | 进货单数据里面的条目 |


（3）模块内部类的接口规范<br>

<center>**PurchaseController的接口规范**</center>
<table><tbody>
<tr>
<th colspan = "3">提供的服务（供接口）</th>
</tr>
<tr>
<th rowspan="3">PurchaseController.getPurchaseID</th>
<th>语法</th>
<th>public String getPurchaseID()</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Purchase领域对象，并且输入符合输入规则</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Purchase领域对象的方法</th>
</tr>
<tr>
<th rowspan="3">PurchaseController.getPurchaseBackID</th>
<th>语法</th>
<th>public String getPurchaseBackID()</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Purchase领域对象，并且输入符合输入规则</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Purchase领域对象的方法</th>
</tr>
<tr>
<th rowspan="3">PurchaseController.addCommodities</th>
<th>语法</th>
<th>public ResultMessage addCommodities(CommodityItem item)</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Purchase领域对象，添加商品和数量，并且输入符合输入规则</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Purchase领域对象的addCommodities方法</th>
</tr>
<tr>
<th rowspan="3">PurchaseController.getTotal</th>
<th>语法</th>
<th>public double getTotal()</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Purchase领域对象，已添加商品和数量</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Sale领域对象的getTotal方法</th>
</tr>
<tr>
<th rowspan="3">PurchaseController.save</th>
<th>语法</th>
<th>public ResultMessage save()</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Purchase领域对象</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Purchase领域对象的方法</th>
</tr>
<tr>
<th rowspan="3">PurchaseController.submit</th>
<th>语法</th>
<th>public ResultMessage submit()</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个Purchase领域对象</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Purchase领域对象的方法</th>
</tr>
</table>

<table><tbody>
<tr>
<th colspan = "2">需要的服务（需接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>Sales.getSalesID</th>
<th>获取进货单的ID</th>
</tr>
<tr>
<th>Sales.getSaleBackID</th>
<th>获取进货退货单的ID</th>
</tr>
<tr>
<th>salesDataService.addCommodities(CommodityPO po)</th>
<th>添加商品</th>
</tr>
<tr>
<th>salesDataService.getTotal(CommodityPO po)</th>
<th>计算总额</th>
</tr>
<tr>
<th>Sales.save</th>
<th>保存草稿</th>
</tr>
<th>Sales.submit</th>
<th>提交单据</th>
</tr>
</table>

<center>**Purchase的接口规范**</center>
<table><tbody>
<tr>
<th colspan="3">提供的服务（供接口）</th>
</tr>
<tr>
<th rowspan="3">Purchase.findCommodities</th>
<th>语法</th>
<th>public ResultMessage findCommodities(String id)</th>
</tr>
<tr>
<th>前置条件</th>
<th>启动一个制定进货单回合</th>
</tr>
<tr>
<th>后置条件</th>
<th>在一个进货回合中，查找一个目标商品</th>
</tr>
<tr>
<th rowspan="3">Purchase.addCommodities</th>
<th>语法</th>
<th>public ResultMessage addCommodities(CommodityPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>启动一个进货回合</th>
</tr>
<tr>
<th>后置条件</th>
<th>在一个进货回合中，添加一个商品</th>
</tr>
<tr>
<th rowspan="3">Purchase.deleteCommodities</th>
<th>语法</th>
<th>public ResultMessage deleteCommodities(CommodityPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>启动一个进货回合</th>
</tr>
<tr>
<th>后置条件</th>
<th>在一个进货回合中，删除一个商品</th>
</tr>
<tr>
<th rowspan="3">Purchase.updeteCommodities</th>
<th>语法</th>
<th>public ResultMessage updeteCommodities(CommodityPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>启动一个进货回合</th>
</tr>
<tr>
<th>后置条件</th>
<th>在一个进货回合中，修改一个商品的属性，如数量</th>
</tr>
<tr>
<th rowspan="3">Purchase.getTotal</th>
<th>语法</th>
<th>public ResultMessage getTotal(CommodityPO po)</th>
</tr>
<tr>
<th>前置条件</th>
<th>已完成一次进货(退货)单的制定</th>
</tr>
<tr>
<th>后置条件</th>
<th>返回此进货回合中的总额</th>
</tr>
</table>

<table><tbody>
<tr>
<th colspan = "2">需要的服务（需接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>PurchaseDataService.findCommodities(String id)</th>
<th>根据ID进行查找单一持久化对象</th>
</tr>
<tr>
<th>PurchaseDataService.finds(String field,int value)</th>
<th>根据字段名和值查找多个持久化对象</th>
</tr>
<tr>
<th>PurchaseDataService.insert(CommodityPO po)</th>
<th>增加单一持久化对象</th>
</tr>
<tr>
<th>PurchaseDataService.delete(CommodityPO po)</th>
<th>删除单一持久化对象</th>
</tr>
<tr>
<th>PurchaseDataService.update(CommodityPO po)</th>
<th>更新单一持久化对象</th>
</tr>
<tr>
<th>DataFactory.getPurchaseDatabase</th>
<th>得到Purchase数据库的服务的引用</th>
</tr>
</table>

（4）业务逻辑层的动态模型<br>

该图所示展示了当一名进货销售人员想要将商品添加进进货单时，进货业务逻辑处理的相关对象之间的协作<br>
<img src="../img/软件详细设计图/Purchase.addCommodity.png">


该图展示了进货人员需要进行单据的提交时，进货业务逻辑处理的相关对象之间的协作<br>
<img src="../img/软件详细设计图/submitPurchase.png">


该图展示了进货人员需要进行单据的保存时，进货业务逻辑处理的相关对象之间的协作<br>
<img src="../img/软件详细设计图/savePurchase.png">


该图所示的状态图描述了Purchase对象的生存期间的状态序列、引起转移的事件，以及因状态转移而伴随的动作<br>
<img src="../img/软件详细设计图/Purchase对象状态图.png">

 (5)业务逻辑层的设计原理<br>
利用委托式风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。

<<<<<<< HEAD
4.1.9 promotionbl 模块<br>
（1）模块概述<br>
promotionbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br>
promotionbl模块的职责及接口参见软件系统结构描述文档表<br>

（2）整体结构<br>
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加bussinesslogicservice. PromotionBLService接口。业务逻辑层和数据层之间添加dataservice. PromotionDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了PromotionController，这样PromotionController会将对客户的逻辑业务处理委托给Promotion对象。PromotionPO是作为客户的持久化对象被添加到设计模型中去的。
Promotionbl模块的设计如图

<img src="../img/软件详细设计图/制定销售策略设计类图.png">
Promotionbl各个类的职责如图
| **模块** | **职责** |
| PromotionController | 负责实现制定销售策略界面所需要的服务 |
| Promotion | 制定销售策略的领域模型对象 |
（3）模块内部类的接口规范<br>
<center>**Promotion的接口规范**</center>
<table><tbody>
<tr>
<th colspan="3">提供的服务（供接口）</th>
</tr>
<tr>
<th rowspan="3">Promotion.getPromotion</th>
<th>语法</th>
<th>public ArrayList<PromotionVO> getCommodityPromotionListByID(int commodityID)</th>
</tr>
<tr>
<th>前置条件</th>
<th>关键字符合输入条件，id符合输入条件</th>
</tr>
<tr>
<th>后置条件</th>
<th>查询到目标销售策略</th>
</tr>
<tr>
<th rowspan="3">Promotion.getID</th>
<th>语法</th>
<th>public String getBillID</th>
</tr>
<tr>
<th>前置条件</th>
<th>类型、名字、级别、电话、地址、邮编等符合输入条件</th>
</tr>
<tr>
<th>后置条件</th>
<th>成功获得账单ID</th>
</tr>
<tr>
<th rowspan="3">Promotion.getclientID()</th>
<th>语法</th>
<th>public String getclientID()</th>
</tr>
<tr>
<th>前置条件</th>
<th>属性符合输入条件</th>
</tr>
<tr>
<th>后置条件</th>
<th>成功获得客户ID</th>
</tr>
<tr>
<th rowspan="3">Promotion.getclientName</th>
<th>语法</th>
<th>public String getclientName()</th>
</tr>
<tr>
<th>前置条件</th>
<th>输入的客户ID符合输入条件</th>
</tr>
<tr>
<th>后置条件</th>
<th>成功获得客户姓名</th>
</tr>
</table>
<table><tbody>

<table><tbody>
<tr>
<th colspan = "2">需要的服务（需接口）</th>
</tr>

</tr>
</table>

（4）业务逻辑层的动态模型<br>
该图展示了当总经理想要制定销售策略的时候，制定销售策略业务逻辑处理的相关对象之间的协作<br>
<img src="../img/软件详细设计图/制定销售策略顺序图.png">
=======
4.1.10 billbl模块<br>
（1）模块概述<br>
billbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br>
billbl模块的职责及接口参见软件系统结构描述文档表<br>
（2）整体结构<br>
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加bussinesslogicservice.billblservice.billBLService接口。业务逻辑层和数据层之间添加dataservice.billdataservice.BillDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了BillController，这样BillController会将对商品的业务逻辑处理委托给Bill对象。BillPO是作为单据记录的持久化对象添加到设计模型中去的。BillList封装了关于Bill的数据集合的数据结构的秘密和计算总数的职责。InventoryBill、PurchaseAndSalesBill和Financial继承了Bill总类。Commodityinfo、Salesinfo和Accountinfo是根据依赖倒置原则，为了消除循环依赖而产生的接口。<br>
<img src="../img/软件详细设计图/bill模块各个类的设计.png"><br>
<center>**bill模块各个类的设计**</center>
<table><tbody>
<tr>
<th>模  块</th>
<th>职  责</th>
</tr>
<tr>
<th>LoginController</th>
<th>负责实现对应于登录界面所需要的服务</th>
</tr>
<tr>
<th>BillController</th>
<th>负责实现单据界面所需要的服务</th>
<tr>
<th>Bill</th>
<th>单据的领域模型对象，拥有一个单据所持有的编号、时间等信息，可以帮助完成单据界面所需要的服务</th>
</tr>
<tr>
<th>BillList</th>
<th>单据清单的领域模型对象，拥有一系列单据所持有的编号、时间、状态等信息，可以帮助完成单据界面所需要的服务</th>
</tr>
<tr>
<th>InventoryBill</th>
<th>库存单据类的领域模型对象，拥有库存单据所持有的商品、进出数量等信息</th>
</tr>
<tr>
<th>PurchaseAndSalesBill</th>
<th>销售和进退货类的领域模型对象，拥有销售进出货所持有的商品、进出数量等信息</th>
</tr>
<tr>
<th>FinancialBill</th>
<th>收付款类的领域模型对象，拥有收付款项等信息</th>
</tr>
</table>

（3）模块内部类的接口规范
<center>**BillController的接口规范**</center>
<table><tbody>
<tr>
<th colspan = "3">提供的服务（供接口）</th>
</tr>
<tr>
<th rowspan="3">BillController.check(BillList list)</th>
<th>语法</th>
<th>public ResultMessage check(BillList list)</th>
</tr>
<tr>
<th>前置条件</th>
<th>已创建一个BillList领域对象，已有单据进入待审批状态，并且输入符合输入规则</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Bill领域对象的check方法</th>
</tr>
<tr>
<th rowspan="3">BillController.sendMessage()</th>
<th>语法</th>
<th>public ResultMessage sendMessage</th>
</tr>
<tr>
<th>前置条件</th>
<th>总经理已执行了单据审批操作，返回单据审批结果信息</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用Bill领域对象的sendMessage方法</th>
</tr>
</table>

<center>**Bill的接口规范**</center>
<table><tbody>
<tr>
<th colspan = "3">提供的服务（供接口）</th>
</tr>
<tr>
<th rowspan="3">Bill.check(BillList list)</th>
<th>语法</th>
<th>public ResultMessage check(BillList list)</th>
</tr>
<tr>
<th>前置条件</th>
<th>已进行一次单据的集合</th>
</tr>
<tr>
<th>后置条件</th>
<th>返回单据清单对象</th>
</tr>
<tr>
<th rowspan="3">Bill.sendMessage()</th>
<th>语法</th>
<th>public ResultMessage sendMessage()</th>
</tr>
<tr>
<th>前置条件</th>
<th>单据已经进入待审批状态</th>
</tr>
<tr>
<th>后置条件</th>
<th>返回单据审批结果</th>
</tr>
</table>
<table><tbody>
<tr>
<th colspan = "2">需要的服务（需接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>BillDataService.find(String id)</th>
<th>根据ID进行查找单一持久化对象</th>
</tr>
<tr>
<th>BillDataService.finds(String field,int value)</th>
<th>根据字段名和值查找多个持久化对象</th>
</tr>
<tr>
<th>BillDataService.insert(BillPO po)</th>
<th>插入单一持久化对象</th>
</tr>
<tr>
<th>BillDataService.update(BillPO po)</th>
<th>更新单一持久化对象</th>
</tr>
<tr>
<th>DataFactory.getBillDatabase</th>
<th>得到Bill数据库的服务的引用</th>
</tr>
</table>

（4）业务逻辑层的动态模型
该图表明了SIMS系统中，当用户点击输入新增添的单据之后，单据业务逻辑处理相关对象之间的协作<br>
<img src="../img/软件详细设计图/添加单据的顺序图.png"><br>
该图表明了SIMS系统中，当用户点击输入查询单据之后，单据业务逻辑处理相关对象之间的协作<br>
<img src="../img/软件详细设计图/查询单据的顺序图.png"><br>

4.1.11 checktablebl 模块<br>
（1）模块概述<br>
checktablebl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br>
checktablebl模块的职责及接口参见软件系统结构描述文档表<br>
（2）整体结构<br>
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加bussinesslogicservice. checktableBLService接口。业务逻辑层和数据层之间添加dataservice. checktableDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了checktableController，这样checktableController会将对客户的逻辑业务处理委托给checktable对象。checktablePO是作为客户的持久化对象被添加到设计模型中去的。
checktablebl模块的设计如图

checktablebl各个类的职责如图
| **模块** | **职责** |
| checktableController | 负责实现制定销售策略界面所需要的服务 |
| checktable | 制定销售策略的领域模型对象 |
（3）模块内部类的接口规范<br>
<center>**checktable的接口规范**</center>
<table><tbody>
<tr>
<th colspan="3">提供的服务（供接口）</th>
</tr>
<tr>
<th rowspan="3">checktable.FinancialDocPO viewReport</th>
<th>语法</th>
<th>FinancialDocPO viewReport(BusinessHistorySchedulePO businessHistorySchedulePO)</th>
</tr>
<tr>
<th>前置条件</th>
<th>关键字符合输入条件</th>
</tr>
<tr>
<th>后置条件</th>
<th>查询到目标报表</th>
</tr>
<tr>
<th rowspan="3">checktable.exportReport</th>
<th>语法</th>
<th>public void exportReport()</th>
</tr>
<tr>
<th>前置条件</th>
<th>符合输入条件</th>
</tr>
<tr>
<th>后置条件</th>
<th>导出报表</th>
</tr>
<tr>
<th rowspan="3">checktable.writeOff</th>
<th>语法</th>
<th>public void writeOff()</th>
</tr>
<tr>
<th>前置条件</th>
<th>属性符合输入条件</th>
</tr>
<tr>
<th>后置条件</th>
<th>红冲</th>
</tr>
<tr>
<th rowspan="3">checktable.writeOffAndCopy</th>
<th>语法</th>
<th>public void writeOffAndCopy(BillPO billPO)</th>
</tr>
<tr>
<th>前置条件</th>
<th>符合输入条件</th>
</tr>
<tr>
<th>后置条件</th>
<th>红冲并复制</th>
</tr>
</table>
<table><tbody>

<table><tbody>
<tr>
<th colspan = "2">需要的服务（需接口）</th>
</tr>

</tr>
</table>

（4）业务逻辑层的动态模型<br>
该图展示了当财务人员想要查看表格的时候，查看表格业务逻辑处理的相关对象之间的协作<br>

4.2.1 mainui模块<br>
（1）模块概述<br>
mainui模块承担的需求为登录主界面需求<br>
mainui模块的职责及接口为登录user的使用概况<br>
（2）整体结构<br>
为提供给业务逻辑层，我们直接使用bussinesslogicservice.userblservice.UserBLService接口来调用关于用户的信息。
<center>**mainui模块各个类的设计**</center>
<table><tbody>
<tr>
<th>模  块</th>
<th>职  责</th>
</tr>
<tr>
<th>mainui</th>
<th>负责实现对应于登录界面所需要的服务</th>
</tr>
</table>
（3）模块内部类的接口规范
<center>**mainui的接口规范**</center>
<table><tbody>
<tr>
<th colspan = "3">提供的服务（供接口）</th>
</tr>
<tr>
<th rowspan="3">MainUI.sendinfo</th>
<th>语法</th>
<th>public ResultMessage login(String info)</th>
</tr>
<tr>
<th>前置条件</th>
<th>已输入用户名和密码，并且输入符合输入规则</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用mainui领域对象的login方法</th>
</tr>
<tr>
<th rowspan="3">MainUI.register</th>
<th>语法</th>
<th>public ResultMessage register(String info)</th>
</tr>
<tr>
<th>前置条件</th>
<th>已输入新用户名和密码，并且输入符合输入规则</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用mainui领域对象的register方法</th>
</tr>
</table>

<table><tbody>
<th colspan = "2">需要的服务（需接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>UserDataService.isExist(String info)</th>
<th>根据ID和密码判断是否存在该用户</th>
</tr>
</table>

4.2.2 commodityui模块<br>
（1）模块概述<br>
commodityui模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br>
commodityui模块的职责及接口参见软件系统结构描述文档表<br>
（2）整体结构<br>
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加bussinesslogicservice.commodityblservice.CommodityBLService接口与bussinesslogicservice.commodityblservice.ClassificationBLService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了CommodityControllerUI，这样CommodityControllerUI会将对商品的业务逻辑处理委托给Commodity对象。CommodityVO和ClassificationVO是作为商品和其分类的记录的可视化对象添加到设计模型中去的。presentation.billui.BillUI则是由发出单据制作要求后新起的一个界面而制定的一个链接。<br>
<img src="../img/软件详细设计图/CommodityUI.png"><br>
<center>**CommodityUI模块各个类的设计**</center>
<table><tbody>
<tr>
<th>模  块</th>
<th>职  责</th>
</tr>
<tr>
<th>CommodityControllerUI</th>
<th>负责实现对应于库存管理人员主界面所需要的服务</th>
</tr>
<tr>
<th>CommodityUI</th>
<th>商品管理的模型对象，拥有一个商品所持有的数量、售价等信息以及其方法</th>
</tr>
<tr>
<th>ClassificationUI</th>
<th>商品分类管理的模型对象，拥有一个商品分类所持有的数量、商品等信息以及其方法</th>
</tr>
</table>

（3）模块内部类的接口规范
<center>**CommodityControllerUI的接口规范**</center>
<table><tbody>
<tr>
<th colspan = "3">提供的服务（供接口）</th>
</tr>
<tr>
<th rowspan="3">CommodityControllerUI.exit</th>
<th>语法</th>
<th>public ResultMessage exit()</th>
</tr>
<tr>
<th>前置条件</th>
<th>当界面需要注销</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用CommodityUI领域对象的exit方法</th>
</tr>
<tr>
<th rowspan="3">CommodityControllerUI.makeInventoryBill</th>
<th>语法</th>
<th>public ResultMessage makeInventoryBill()</th>
</tr>
<tr>
<th>前置条件</th>
<th>需要进行制作单据操作</th>
</tr>
<tr>
<th>后置条件</th>
<th>调用CommodityUI领域对象的makeInventoryBill</th>
</tr>
</table>

<center>**CommodityUI的接口规范**</center>
<table><tbody>
<tr>
<th colspan = "2">需要的服务（需接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>CommodityBLService.find(long id)</th>
<th>根据ID进行查找单一可视化对象</th>
</tr>
<tr>
<th>CommodityBLService.finds(String field,int value)</th>
<th>根据字段名和值查找多个可视化对象</th>
</tr>
<tr>
<th>CommodityBLService.insert(CommodityVO vo)</th>
<th>插入单一可视化对象</th>
</tr>
<tr>
<th>CommodityBLService.delete(CommodityVO vo)</th>
<th>删除单一可视化对象</th>
</tr>
<tr>
<th>CommodityBLService.update(CommodityVO vo)</th>
<th>更新单一可视化对象</th>
</tr>
<tr>
<th>CommodityBLService.check()</th>
<th>查看库存中的一段时间的对象</th>
</tr>
<tr>
<th>CommodityBLService.stock()</th>
<th>查看库存中的给定要求的商品对象</th>
</tr>
</table>

<center>**ClassificationUI的接口规范**</center>
<table><tbody>
<tr>
<th colspan = "2">需要的服务（需接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>ClassificationBLService.insertClass(ClassificationVO vo)</th>
<th>插入单一可视化对象</th>
</tr>
<tr>
<th>ClassificationBLService.deleteClass(ClassificationVO vo)</th>
<th>删除单一可视化对象</th>
</tr>
<tr>
<th>ClassificationBLService.updateClass(ClassificationVO vo)</th>
<th>更新单一可视化对象</th>
</tr>
</table>

4.2.3 userui模块<br>
（1）模块概述<br>
userui模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br>
userui模块的职责及接口参见软件系统结构描述文档表<br>
（2）整体结构<br>
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加bussinesslogicservice.userblservice.UserBLService接口。UserVO是作为用户的记录的可视化对象添加到设计模型中去的。<br>
<center>**UserUI模块各个类的设计**</center>
<table><tbody>
<tr>
<th>模  块</th>
<th>职  责</th>
</tr>
<tr>
<th>UserUI</th>
<th>用户管理的模型对象，拥有一个用户所持有的用户名密码等信息以及其方法</th>
</tr>
</table>

<center>**UserUI的接口规范**</center>
<table><tbody>
<tr>
<th colspan = "2">需要的服务（需接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>UserBLService.find(long id)</th>
<th>根据ID进行查找单一可视化对象</th>
</tr>
<tr>
<th>UserBLService.insert(UserVO vo)</th>
<th>插入单一可视化对象</th>
</tr>
<tr>
<th>UserBLService.delete(UserVO vo)</th>
<th>删除单一可视化对象</th>
</tr>
<tr>
<th>UserBLService.update(UserVO vo)</th>
<th>更新单一可视化对象</th>
</tr>
</table>

4.3.1 commoditydata模块<br>
（1）模块概述<br>
commoditydata模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br>
commoditydata模块的职责及接口参见软件系统结构描述文档表<br>
（2）整体结构<br>
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。业务逻辑层和数据层之间添加dataservice.commoditydataservice.CommodityDataService接口和dataservice.commoditydataservice.ClassificationDataService接口。CommodityData是承接商品的各类数据的，而ClassificationData是作为商品的分类而聚合在其中。<br>
<img src="../img/软件详细设计图/CommodityData.png"><br>
<center>**CommodityData模块各个类的设计**</center>
<table><tbody>
<tr>
<th>模  块</th>
<th>职  责</th>
</tr>
<tr>
<th>CommodityData</th>
<th>商品的模型对象，拥有一个商品各类数据及其方法</th>
</tr>
<tr>
<th>ClassificationData</th>
<th>商品分类的模型对象，拥有一个商品分类各类数据及其方法</th>
</tr>
</table>

（3）模块内部类的接口规范
<center>**CommodityData的接口规范**</center>
<table><tbody>
<tr>
<th colspan = "2">提供的服务（供接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>CommodityData.find(long id)</th>
<th>根据ID进行查找单一持久化对象</th>
</tr>
<tr>
<th>CommodityData.finds(String field,int value)</th>
<th>根据字段名和值查找多个持久化对象</th>
</tr>
<tr>
<th>CommodityData.insert(CommodityPO po)</th>
<th>插入单一持久化对象</th>
</tr>
<tr>
<th>CommodityBLService.delete(CommodityPO po)</th>
<th>删除单一持久化对象</th>
</tr>
<tr>
<th>CommodityBLService.update(CommodityPO po)</th>
<th>更新单一持久化对象</th>
</tr>
</table>

<center>**ClassificationUI的接口规范**</center>
<table><tbody>
<tr>
<th colspan = "2">需要的服务（需接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>ClassificationBLService.insertClass(ClassificationPO po)</th>
<th>插入单一持久化对象</th>
</tr>
<tr>
<th>ClassificationBLService.deleteClass(ClassificationPO po)</th>
<th>删除单一持久化对象</th>
</tr>
<tr>
<th>ClassificationBLService.updateClass(ClassificationPO po)</th>
<th>更新单一持久化对象</th>
</tr>
</table>

4.3.2 userdata模块<br>
（1）模块概述<br>
userdata模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br>
userdata模块的职责及接口参见软件系统结构描述文档表<br>
（2）整体结构<br>
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。业务逻辑层和数据层之间添加dataservice.userdataservice.CommodityDataService接口。UserData是承接用户的各类数据的。<br>
<center>**UserData模块各个类的设计**</center>
<table><tbody>
<tr>
<th>模  块</th>
<th>职  责</th>
</tr>
<tr>
<th>UserData</th>
<th>用户的模型对象，拥有一个用户各类数据及其方法</th>
</tr>
</table>

（3）模块内部类的接口规范
<center>**UserData的接口规范**</center>
<table><tbody>
<tr>
<th colspan = "2">提供的服务（供接口）</th>
</tr>
<tr>
<th>服务名</th>
<th>服务</th>
</tr>
<tr>
<th>UserData.find(long id)</th>
<th>根据ID进行查找单一持久化对象</th>
</tr>
<tr>
<th>UserData.finds(String field,int value)</th>
<th>根据字段名和值查找多个持久化对象</th>
</tr>
<tr>
<th>UserData.insert(UserPO po)</th>
<th>插入单一持久化对象</th>
</tr>
<tr>
<th>UserService.delete(UserPO po)</th>
<th>删除单一持久化对象</th>
</tr>
<tr>
<th>UserBLService.update(UserPO po)</th>
<th>更新单一持久化对象</th>
</tr>
</table>

>>>>>>> refs/remotes/origin/master

##5.依赖视角
下面两图是客户端和服务器各自的包之间的依赖关系<br>
<img src="../img/客户端开发包图.png"><br>
<center>客户端包图</center>
<img src="../img/服务端开发包.png"><br>
<center>服务器端端包图</center>
